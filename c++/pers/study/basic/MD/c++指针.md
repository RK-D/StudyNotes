#指针
###1 基础知识纠错
####1.1变量三要素 
##### 1)基础数据类型
* （1）short long signed unsigned (用于限定整型，signed可以省略，unsigned表示正数,其他可以声明时省略 int)
* （2）下列代码可以查看字节数（short 2字节  vc中int 4字节否则为2字节,这主演看电脑是多少位机器 ，1字节位长度 8）
    ```
    cout << sizeof(char) << endl;
    cout << sizeof(int) << endl;
    cout << sizeof(float) << endl;
    cout << sizeof(double) << endl;
    ```
* （3）C 还定义四种"存储类型"： auto（自动型） ，extern（外部型） ， static（静态型） ，register（寄存器型）
* （4）ps：auto 可以省略其他不可省略 如auto int  a和 int  a等价。当然c++ 也可以只声明 auto a 此时c默认是 int 型 也就是auto int a 。
##### 2）变量的名字和声明
* （1）C语言中大小写字母是具有不同含义的
* （2）在现在的编译系统中，内部名字中至少前31个字符是有效的，所以应该采用直观的名字。一般可以遵循如下简单规律。
    
  ```
    参照三大命名法则
    1）使用能代表数据类型的前缀。
    2）名称尽量接近变量的作用。
    3）如果名称由多个英文单词组成，每个单词的第一个字母大写。
    4）由于库函数通常使用下划线开头的名字，因此不要将这类名字用作变量名。
    5）局部变量使用比较短的名字，尤其是循环控制变量（又称循环位标）的名字。
    6）外部变量使用比较长且贴近所代表变量的含义。
    7）函数名字使用动词，如Get_char(void)。变量使用名词，如iMen_Number。
    ```
* （3）应该养成在声明时就为变量赋初值的习惯，但在某些特殊场合则只能声明，如头文件中对外部变量的声明，下面是一些典型的例子。
    ```
  auto int a;
  static int getSize = 10;
  const double pi = 3.14;
  register int b = 2; 
    ```
##### 3）变量的地址
* 在C语言中，声明和定义两个概念是有区别的。声明是对一个变量的性质（如构成它的数据类型）加以说明，并不为其分配存储空间；
* 定义则是既说明一个变量的性质，又为其分配存储空间。
* 在设计C程序时，对指针的初始化有两种方法：使用已有变量的地址或者为它分配动态存储空间。好的设计方法是尽可能地早点为指针赋值，以免遗忘造成使用未初始化的指针。
###1.2变量操作
*  （1）左值和右值概念
    * 1.1变量是一个指名的存储区域，左值是指向某个变量的表达式。左值”来源于赋值表达式“A=B”，其中左运算分量“A”必须能被计算和修改。左值表达式在赋值语句中既可以作为左操作数，也可以作为右操作数。
    常量只能作为右值，而普通变量既可以作为左值，也可以作为右值。
    ``` 
   const int a = 100; //定义的a，显然不能作为左值，只能作为右值。
    ```
    * 1.2因此，值可以作为右值，如整数、浮点数、字符串、数组的一个元素等。在C语言中，右值以单一值的形式出现。假设有字符数组a和b，则这两个字符数组的每个元素均可以作为右值，即“a[0]=b[0]”是正确的，“b[0]=a[0]”也是正确的。需要注意的是，它们在“=”号左右两边的含义是不同的。以a[0]为例，在“b[0]=a[0]”中，它是作为值出现的，即a[0]是数组第1个元素的值；而在“a[0]=b[0]”中，它是作为变量出现的，即a[0]是数组的第1个元素的变量名，所以a[0]可以作为左值。即可以使用数组的具体元素作为左值和右值
    * 1.3总结：在C语言中，左值是一个具体的变量，右值一定是一个具体类型的值。
* （2）对变量的基本操作
    * C 中用 & 取变量地址，那么用 * 来解地址
    ```
  int a = 10;
  cout << a << '\n'<< *& a << endl; // 前后的值相同，也就是a 与*& a 等价;
    ```
###1.3指针变量
* （1）对有效地址操作
    * 1.1 （计算机内可以存取的地址称为有效地址）
    ``` 
  #include <iostream>
  using namespace std;
  int main() {
          int a = 10;
          int * adr =(int *) 0x7cfe14; //0x7cfe14是a 的地址，可以用&a代替
          cout << &a << '\n' <<  adr <<'\n' <<  (int* )adr << endl;
          cout << a  << '\n' << *&a  <<'\n' << *(int* )adr << endl; 
          return 0;
  }
     /** 0x7cfe14
       * 0x7cfe14
       * 0x7cfe14
       * 10
       * 10
       * 10
       * */
    ```
* （2）来吧！指针
    ```
  int p; //这是一个普通的整型变量
  int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针
  int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组
  int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组
  int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针
  int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.
  int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据
  Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针
  int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.
     ```
    * 
    ``` 
  int *adr = &a;
  //int *adr = (int) &a; error:从指针强制转换为较小类型“ int”会丢失信息
    ```
  ps:(*). 和 -> 是同一个符号
   ```
    typedef  struct a{
     }b，*c;
    /**意思是 将struct a  用b代替，下面的程序就是b相当于一个数据类型，作用与struct a  一样的
    C也代表a的另一个名称，但是C定义是一个指针类型的别称
    a      e1;
    b      e2;
    c      e3;
    如果你的结构体中有一个变量data;
    那么引用时就会是这样的：e1.val=1,e2.val=2;e3->val=3;
    就相当于，e3是一个指向这种结构体的一个指针。

    */
    struct a *p，则p->num;
    struct a p,则 p.num;
   ```
   对结构变量本身进行操作时，必须用“.”运算符。但若使用结构指针，必须使用 -> 运算符。
###2 指针基础
 * 指向常量的指针 
    ```
    const int y = 2;
    const int *p1;
    p1 = &y;
    //    *p1 = &y; error:*p解p指针，解出来的是常量，const常量不能作为左值。
    const int *p2 = &y;
    cout << *p1<< '\n'<< *p2 << endl;
   
    int *p2;
    int a = 1;
    p1 = &a;
    a = 10;
    p2 = (int *)*y;
    //指向常量的指针可以指向变量但无法通过指针操作变量，但是间接改变变量仍然可以， const仅仅限制常量不直接做左值，间接仍然可以改变
    ```
  * 常量指针
     * 将const限定符放在*号的右边，就使指针本身成为一个const指针。指针本身是常量，编译器要求必须初始化值，
       即声明时必须初始化指针，并且这个值在指针的整个生存期中都不会改变。
   
    ```
    int x = 10, y = 20, *p01; //变量都可以做左值
    int const sum = 100 ; //常量只能作为右值
    int * const a = 1;
    int * const b = &x;
    int * const c = (int * )&sum; //使用常量初始化c 指针，必须强转
    x = y; //左值x 间接改变 *b的值， 使得*b = 20;
    *p = sum; //直接使用*p 作为左值，sum值赋给*p
    ``` 
* 指向常量的常量指针
    ``` 
  int a = 1;
  const int *const p = &a; 
    ```
* void 指针 
    * 指针的值只能赋给相同类型的指针。void类型不能声明变量，但可以声明void类型的指针，而且void指针可以指向任何类型的变量
    ```
  int a = 1,b = 2,*p = &a;
  void *vptr = &a; //void 指针指向a
  vptr = &b; //void指针指向b
  p = (int *)vptr; //强制将void 指针赋值给整型指针
    ``` 
 * 动态内存
   * 可以自己申请一块内存，且这块内存也由自己释放，这样分配的内存称为动态内存。
   * C编译程序提供的最主要的内存分配函数是malloc()和calloc ()，能为要写的数据在内存中分配一个安全区
        * 功能都是为要写的数据在内存中分配一个安全区。一旦找到一个大小合适的内存空间，就分配给它们，并将这部分内存的地址作为一个指针返回.
        * malloc和calloc的主要区别是：calloc清除所分配的内存中的所有字节，即将所有字节置零；malloc仅分配一块内存，但所有字节的内容仍然是被分配时所含的随机值。
        * malloc和calloc所分配的内存空间都可以用free函数释放,malloc和calloc之后都要free
    ps:传递给函数时数组会完全退化为指针
    ``` 
   //当sizeof应用在数组上时，它得到的是整个数组所占的空间，因此在主函数中得到3
   //函数定义
   void foo(const int arr[]) 
   //相当于
   void foo(const int *arr) 
   //数组都是这么传递的，因此进入函数后，得到的是指针所占的空间，在32位系统正好是32位，和int所占的空间相同，因此进入函数后结果是1。
    //此外用指针所占的空间，除int所占的空间，没有任何意义。
    ```