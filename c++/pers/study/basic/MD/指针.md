# 指针



## 左值&右值
* 左值：编译器单独为其分配了一块空间，可以取地址，放在赋值运算符左侧
* 右值：数据本身，不能取地址，放右边
 ```
    a = b + c;
    // &a 允许
    // &(b + c) 不允许
 ```

## 指针
* 一般指针 T*（T代替任意类型）
    ```
    int *p = &a; // * 用来定义一个指针 p 按结合性，右->左，*p是一个指针，类型是int
    cout << (*p) << endl; // * 解地址
    ```
* 指针数组&数组指针
    ```
    T *a[] // 指针的数组
    T (*a)[]  //数组的指针
    int * a[4];   
    int (*b)[4]; // [] 优先级比较高
    ```

 ```
  int p; //这是一个普通的整型变量
  int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针
  int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组
  int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组
  int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针
  int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.
  int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据
  Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针
  int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.
```

## const & pointer
* 关于const修饰，（const 就是定义什么不能变，把他规定为常量，起限定修饰作用）
    * 1.看左侧最近的部分；
    * 2.如果左侧没有，则看右侧；
    * const pointer & pointer to const
    ```
        char a[] = {"hello"};
        char const *p1 = "hello"; //const修饰char ，所以指针本身不可变（指针指的地址不能变），对应的值可以变
        const char *p1 = "hello"; //与上面等价
        char *const p2 = "hello";
        char const * const p3 = "hello";
        
        p1 = a;
        // p2 = a;
        // p3 = a;
        
    ```
    
## 指向指针的指针（二级指针啦）
```
    int a = 123;
    int *b = &a;
    int **c = &b;
```
* 操作符具有 左 <- 右 的结合性，
    * ** 相当于  *(*c)表达式，必须从内向外逐层求值，
    * *c得到指向c的地址，即b；
    * **c 相当于*b ，得到变量a 的值；


## 常见c++指针
* 野指针
    * 未初始化和非法的指针
    ```
        int *a; //未初始化，指针必须初始化
        *a = 12; //非法指针
    ```
    * 成因：
        * 1.指针没有初始化
        * 2.已经释放不用的指针没有置NULL，如delete和free之后的指针；
        * 3.指针操作超越了变量的作用范围；
    * 使用：
        没有初始化的，不用或者超出范围的指针请把值置为NULL。
* NULL指针 / nullptr
    * 一个特殊的指针变量，表示不指向任何东西的指针 
    * int *a = NULL; //这也是一种初始化方式  此处最好使用 nullptr
    
## 操作符 & 和 *
* 直接记住 & 1.取地址 2.引用 &a = b; 这里a ，b 是同一个东西，知识单纯名字不同
* *  1.定义指针，2.解地址

## 指针操作
* ++ 与 -- 操作符
* ++++ ----操作符的方法---->贪心算法
    * int a=1,b=2,c;
    * c = a+++b; // a++ + b
    * d = a++++b; // a++ ++b,error