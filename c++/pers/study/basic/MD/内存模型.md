## 内存
* 内存的每块都编号，编号称为地址


## 内存划分
* c划分：栈，堆，全局/静态区（分；两种），常量存储区
  ```
    //c
     int a = 0; //全局初始化区
     char *p1; //全局未初始化区
     void main(){
         int b; //栈
         char s[] = "abc"; //栈
         char *p2; //栈
         char *p3 = "123456"; //123456{post.content}在常量区，p3在栈上
         static int c = 0; //全局（静态）初始化区
         p1 = (char *)malloc(10); //分配得来得10字节的区域在堆区
         p2 = (char *)malloc(20); //分配得来得20字节的区域在堆区
         strcpy(p1, "123456");
         //123456{post.content}放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块
     }
    ```
* c++划分：栈，堆(new/delete)，自由存储区(类似堆，free结束),全局/静态存储区，常量存储区
      ```
      void fun(){
          int *p = new int [10]; // p在栈里，new的int[10]在堆里
          delete []p; //删除用delete []p 明确删除的是一个数组
      }
      ```

* **可执行程序程序三段-Text段，Date段，Bss段**
    * **代码段(text):** 编译时确定,内存中被映射为只读。
    通常是指用来存放程序执行代码的一块内存区域。
	这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(**某些架构也允许代码段为可写，即允许修改**)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
    * **已初始化数据区/数据段(data):** 是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。
    * **未初始化数据区(BSS):** 是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。


    
* **全局/静态区(static)：** 存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块。
    * **ps:**
    全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
* **常量存储区：** 存放的是常量，是不允许修改的。
静态存储是main函数运行前分配内存并初始化；常量存储是固化在执行文件上的数据。

* **栈区：先进后出**
    * 栈由**编译器自动分配释放**，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。
    *  在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（	栈又称堆栈，是用户存放程序临时创建的局部变量，
也就是说我们函数括弧“{}”中定义的变量[但不包括static声明的变量，static意味着在数据段中存放变量]。）
        * 由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
     
* **堆区：亦称动态内存分配**。
    * 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
    * 程序在运行的时候用malloc(c)/free或new(c++)/delete申请/释放任意大小的内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 如果某动态内存不再使用，必需要将其释放掉(内存泄露)，并立即将指针置位NULL/(c++11之后都可以用 nullptr )，防止产生野指针。
        * (野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针变量在定义时如果未初始化，其值是随机的，指针变量的值是别的变量的地址，意味着指针指向了一个地址是不确定的变量，此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。)
* **文字常量区:**
常量字符串就是放在这里的。 程序结束后由系统释放.
* **程序代码区**
存放函数体的二进制代码。

* new/malloc等等在堆区，其他变量在栈内，
* 因为栈小，会溢出，所以需要堆
* 堆没有栈的先进后出，类似链表
* C和C++中，const修饰的变量所在的存储区是不一样的。
    * 在C中，const修饰的变量存储在“栈”中。
    * 在C++中，const修饰的变量被定义为一个常量是放在代码段里的，是在常量存储区中的。
    ```
    #inclode<stdio.h>
    int main(){
        const char a = 't';
        printf("%cc\n",a);
        cha *b = &a;
        *b = 'A';
        printf("%c\n",a);
        return 0;
    }
    //gcc不过
    //g++过
    ```
  ```
  //栈中未初始化 cc 堆中cd
     #include <string>
     int a = 0;                                             //(GVAR)全局初始化区 
     int* p1;                                               //(bss)全局未初始化区 
     int main(){                                            //(text)代码区 
    	int b=1;                                            //(stack)栈区变量 
    	char s[] = "abc";                                   //(stack)栈区变量
    	int*p2=NULL;                                        //(stack)栈区变量
    	char *p3 = "123456";                                //123456\0在常量区, p3在(stack)栈区
    	static int c = 0;                                   //(GVAR)全局(静态)初始化区 
    	p1 = new int(10);                                   //(heap)堆区变量 p1(在全局区) p2本身(&p2)还在栈，
    	p2 = new int(20);                                   //(heap)堆区变量 
    	char* p4 = new char[7];                             //(heap)堆区变量(p4) p4在栈区(&p4)
    	strcpy_s(p4, 7, "123456");                          //(text)代码区
    
    	                       //(text)代码区
    	if (p1 != NULL){
    		delete p1;
    		p1 = NULL;
    	}
    	if (p2 != NULL){
    		delete p2;
    		p2 = NULL;
    	}
    	if (p4 != NULL){
    		delete[ ] p4;
    		p4 = NULL;
    	}
    	                        //(text)代码区
    	return 0;                                            //(text)代码区
    
  ```
  
## 内存区域
高地址 [        stack        ]  //栈只开一个口，先进后出  向下生长 （低->高）编译器决定
       [    unused memory    ]  //可以用来分配的内存
    -- [        heap         ]  //堆内存远远大于栈，向上生长（高->低） 用户自行决定，动态
       [        常量区       ]
  data [        BSS          ]  //未初始化，可以做优化
    -- [      GVAR/data      ]  //已初始化
低地址 [        Text         ]  //代码段
      
      
      
      
## 动态分配内存资源--堆(heap)
* 分配和内存回收动态内存的原则
    * 1.分配一个某个大小的内存块；
    * 2.释放一个之前分配的内存块；
    * 3.垃圾回收操作，寻找不在使用的内存块并予以释放;（性能，实时性，额外开销等平衡）
    * c++做了1，2    /  Java做了1,3
    * 堆内存管理要求较高时，比如游戏之类java就不太行。

## linux分页
//TODO

## 寄存器

* cpu有三种寄存器 
    * eip(永远指向需要执行的下一条指令，两种管控方式：1.顺序执行，2.跳转) 
    * esp
    * ebp
    * 