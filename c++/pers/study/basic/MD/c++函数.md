#c++基础扫盲
##普通函数
* main() -> 调用fun() -> 寻找fun -> 执行fun -> 回到main() -> 结束
##内联函数
* inline
* 编译时将函数体代码 和 实参代替函数调用语句（节省调用时间，尤其循环调用）
* main() -> 执行fun -> 结束
``` 
inline int max(int a ,int b);
int main(){
    int a = 1,b = 2,m;
    m =max(a,b);
    cout << "max = "  << m <<endl;
    return 0;
}
```
* 内联函数是建议性的，由编译器决定。
* 调用频繁的函数建议使用内联函数。
* 递归函数无法使用内联方式，递归函数仍然被当做普通函数执行。
##内存
*  * 内存的本质 -> 资源
   * 操作系统管理内存
   * 我们能 申请（new） 和 归还（delete） 内存 （这两个都是运算符，不是函数）。 \
      c语言中malloc（size_t size）申请，free（void *_Memory）释放;
     * malloc和new从申请的内存所在位置、返回类型安全性、内存分配失败时的返回值、是否需要指定内存大小这四点区分。\
     1、申请的内存所在位置不同new操作符从自由存储区（free store）上为对象动态分配内存空间。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。malloc函数从堆上动态分配内存。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 \
     2、返回类型安全性不同new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 \
     3、内存分配失败时的返回值不同new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL。malloc分配内存失败时返回NULL。 \
     4、是否需要指定内存大小不同使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。malloc则需要显式地指出所需内存的尺寸。
