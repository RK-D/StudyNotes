# 类
## 1.抽象数据类型
* 数据抽象 & 封装
* 接口 & 实现 分离

## 2.作用域
* 类的本身就是作用域
* 成员函数定义嵌套在类的作用域之内
* 类外定义成员函数时:定义与声明必须匹配(返回类型，参数列表，函数名与类内保持一致)

## 3.构造函数
* c++11 后默认使用 = default 定义默认构造函数

## 4.访问&控制 3P
* class默认private
* struct默认public
* class & struct 定义类的唯一区别就是访问权限

## 5.友元 friend
* 让其他类或者函数可以访问它的 !public 成员，此时需要使其他类把一个函数作为它的 友元
```

class Box {
    double width;
public:
    friend void printWidth(Box box);
    friend class BigBox;
    void setWidth(double wid);
};

class BigBox {
public :
    void Print(int width, Box &box){
        // BigBox是Box的友元类，它可以直接访问Box类的任何成员
        box.setWidth(width);
        cout << "Width of box : " << box.width << endl;
    }
};
    
// 成员函数定义
void Box::setWidth(double wid) {
    width = wid;
}

// 请注意：printWidth() 不是任何类的成员函数
void printWidth(Box box) {
    /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
    cout << "Width of box : " << box.width << endl;
}

// 程序的主函数
int main() {
    Box box;
    BigBox big;

    // 使用成员函数设置宽度
    box.setWidth(10.0);

    // 使用友元函数输出宽度
    printWidth(box);

    // 使用友元类中的方法设置宽度
    big.Print(20, box);

    getchar();
    return 0;
}
```
* 友元仅仅定义访问权限，不受原先函数声明的影响，本身也不是成员函数，但是必须在类内出现(类内位置随意)
* 通俗解释： 友元就是告诉外面的朋友你可以使用我(友元)家(友元所在的类)的东西(函数，成员)

## 内联函数 inline 
```
inline int Max(int x, int y){
   return (x > y)? x : y;
}

int main( ){
    cout << "Max (20,10): " << Max(20,10) << endl; 
}

//这段代码执行时，内联函数会把Max加载到main函数替换成Max本省的函数，并带入数据，然后执行，并不是在main中调用Max ，这样达到更快执行的效果

```

* 1.在内联函数内不允许使用循环语句和开关语句；
* 2.内联函数的定义必须出现在内联函数第一次调用之前；
* 3.类结构中所在的类说明内部定义的函数是内联函数。
* 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
    * **定义:** 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.
    
    * **优点:** 
    * 内联该函数可以令目标代码更加高效
    * 对于存取函数以及其它函数体比较短, 性能关键的函数, 使用内联
    
    * **缺点:** 
        * 滥用导致程序变慢
        * 内联可能使目标代码量或增或减
        * 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快
    
    * **结论:** 
    * 不要内联超过 10 行的函数.
    * 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
    
    *  内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).
    
* 有些函数即使声明为内联的也不一定会被编译器内联： **虚函数，递归函数**

    * 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的；
    
    * 虚函数内联的主要原因则是想把它的函数体放在类定义内

## 运算符重载
```
//声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象
Box operator+(const Box&);

//大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数
Box operator+(const Box&, const Box&);


```

* 再举个例子
```
// 重载 < 
struct  Stu{
    std::string name;
    int score;
    bool operator < (const Stu &otherStu){
        return score < otherStu.score;
    }
    //友元声明
    friend std::ostream &operator << (std::ostream &os, const Stu & stu){
        os << "stu: " << stu.name << " " << stu.score << std::endl;
        return os;
    }
}

    
//后期使用 进行创建
//Stu s[4] = {{"a",88}, {"h",99}, {"l",89}, {"f",90}};

    
```

## PS：补充说明
### Overload 重载 (operator)
* 在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括类型、顺序不同），即函数重载。
    * （1）相同的范围（在同一个类中）；
    * （2）函数名字相同；
    * （3）参数不同；

* 请注意，重载解析中不考虑返回类型，而且在不同的作用域里声明的函数也不算是重载。

### Override 覆盖

* 是指派生类函数覆盖基类函数，特征是：
    * （1）不同的范围（分别位于派生类与基类）；
    * （2）函数名字相同；
    * （3）参数相同；
    *  （4）基类函数必须有virtual关键字。

### Overwrite：重写
* 是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
    * （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
    * （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆)


* override是指在不同作用域(一个类就是一个作用域)中，多个函数原型完全一样，而实现却不同的函数。在C++中，经常发生在类的继承中。
* 当基类中的某个方法是virtual或pure virtual函数时（当然访问权限必须是public或protected，因为从C++设计思想上来讲private的函数不会是virtual的），
其子类中对该方法的重新实现就属于override。使用时，可以通过基类的指针或者引用所指向的具体对象来确定调用的是哪个方法，从而实现函数的多态。
* 对于基类中的非virtual类型的成员函数，若其子类中也声明了与该函数名称相同的函数，
那么基类中的该函数（也许是一系列函数，如果该函数在基类中有重载的话，呵呵）将被隐藏，可以通过域解析操作符来调用。
* 不过按照C++的设计思想来说呢，基类中的非virtual类型的成员函数，是不需要在子类中进行修改的，所以如果在子类中出现了这种隐藏的情况，
说明应该将基类中的该函数改成virtual类型的，然后就是override了！
* overload则是指在相同作用域中，多个函数具有相同的名字，但参数的数目和类型各不相同（当然相同数目和类型，如果顺序不同也是可以的，哈哈），因为函数重载的机制是在C++中函数的签名与其参数有关，而不像C中，只与函数名有关。
总之，override与overload的一个最大的区别就是作用域不同，以及函数原型是否相同，呵呵。

* 补充函数的重载(overload)覆盖(override)隐藏

* 派生类的函数与基类的函数完全相同(函数名和参数列表都相同),只是基类的函数没有VIRRUAL关键字.些时基类的函数将被隐藏,而不是覆盖.

* 派生类的函数与基类的函数同名,但参数列表不同,在这种情况下,不管基类的函数声明是否有VIRRUAL关键字,基类的函数都将被隐藏.注意这种情况与重载的区别,重载发生在同一个类中,